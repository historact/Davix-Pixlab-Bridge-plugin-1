# Davix Subscription Bridge – Provisioning Data Audit

## A) Event payload report (activated)
- **Payload keys**: `event`, `customer_email`, `plan_slug`, `subscription_id`, `order_id`, plus optional `valid_from`/`valid_until` from `maybe_add_validity_window`, and `_dsb_validity_backfill` when backfilling validity. These are assembled in `DSB_Events::build_payload()` and `maybe_add_validity_window()`.【F:includes/class-dsb-events.php†L681-L766】【F:includes/class-dsb-events.php†L770-L862】【F:includes/class-dsb-events.php†L600-L619】
- **customer_email**: pulled from `$order->get_billing_email()` when order is present; if empty, falls back to subscription meta `user_id` → `get_user_by( 'id' )` email. No other sources are used, so payloads with missing order and no subscription `user_id` meta are dropped as `customer_missing`.【F:includes/class-dsb-events.php†L698-L752】
- **wp_user_id**: never collected or added to payload. The only user lookup is for deriving email from subscription `user_id` meta, and the value is not persisted in payload or DB.【F:includes/class-dsb-events.php†L707-L715】
- **customer_name**: not populated anywhere in payload construction; no billing name or WP user display name is read.【F:includes/class-dsb-events.php†L681-L766】
- **subscription_status**: not captured. Payload contains only `event` string derived from hooks/status mapping; no status value is added.【F:includes/class-dsb-events.php†L250-L267】【F:includes/class-dsb-events.php†L681-L766】

## B) WooCommerce / WP user extraction report
- **Functions used**: `WC_Order::get_billing_email()` for email, `get_post_meta( $subscription_id, 'user_id' )` + `get_user_by( 'id' )` as fallback; no use of `$order->get_user_id()` or `get_userdata()` during payload build.【F:includes/class-dsb-events.php†L698-L715】
- **Missing user capture**: wp_user_id is never read or sent; customer name not read. Recommended extraction points per hook:
  - **Checkout/order hooks** (`handle_checkout`, `handle_order_status_change`): add `$order->get_user_id()` and billing first/last name from `$order` to payload when available.【F:includes/class-dsb-events.php†L184-L220】【F:includes/class-dsb-events.php†L681-L766】
  - **WPS subscription hooks** (`handle_wps_subscription_created`, `handle_wps_subscription_order_created`, `handle_wps_subscription_process_checkout`): when `$order` is available, capture `$order->get_user_id()` and billing names; otherwise read `user_id` meta from the subscription object/post to populate user/email/name consistently.【F:includes/class-dsb-events.php†L96-L182】
  - **Renewal/expire/cancel hooks**: derive user/email/name from subscription meta (user_id) or parent order using `find_subscription_id_for_order` + `wc_get_order` then `$order->get_user_id()`/billing names before building payload.【F:includes/class-dsb-events.php†L80-L95】【F:includes/class-dsb-events.php†L270-L319】

## C) DB schema + upsert report
- **Schema (created on activation)**: `davix_bridge_keys` columns: `id`, `subscription_id` (UNIQUE), `customer_email` (indexed), `plan_slug`, `status`, `key_prefix`, `key_last4`, `valid_from`, `valid_until`, `node_plan_id`, `last_action`, `last_http_code`, `last_error`, timestamps. Only `subscription_id` is unique—there is no column for `wp_user_id`, `customer_name`, or `subscription_status`, and no uniqueness on `customer_email`.【F:includes/class-dsb-db.php†L22-L64】
- **Upsert logic**: `DSB_DB::upsert_key()` looks up existing row by `subscription_id` only; if present, it preserves current `valid_until` when new data passes `null`, then updates that row, else inserts. Matching never considers email or user, so new subscription IDs for the same customer create additional rows.【F:includes/class-dsb-db.php†L113-L144】
- **No migration for additional uniqueness**: table definition and upsert contain no unique constraints on `customer_email` or combined keys; no migration helpers beyond `create_tables()`.【F:includes/class-dsb-db.php†L22-L64】【F:includes/class-dsb-db.php†L113-L144】

## D) Node request/response report
- **Request builder**: `DSB_Client::request()` posts JSON to `/internal/subscription/event` with `x-davix-bridge-token` header; body is `wp_json_encode( $payload )`.【F:includes/class-dsb-client.php†L270-L297】【F:includes/class-dsb-client.php†L329-L333】
- **What is sent**: Whatever `build_payload()` returns (event, customer_email, plan_slug, subscription_id, order_id, validity fields) is sent directly; no wp_user_id/name/status fields are added anywhere else.【F:includes/class-dsb-client.php†L329-L333】【F:includes/class-dsb-events.php†L681-L766】
- **Response parsing**: On `status === 'ok'`, it normalizes `valid_from`/`valid_until` from multiple key names, then calls `upsert_key()` with subscription_id, customer_email, plan_slug, status (active/disabled), key prefix/last4, node_plan_id, last_action/http_code. Failures (or logging enabled) also upsert with status `error`. No wp_user_id/name/subscription_status fields are stored from responses.【F:includes/class-dsb-client.php†L329-L395】

## E) Concrete fixes (evidence-based)
1. **Always set `wp_user_id`**: Add columns and payload fields sourced from `$order->get_user_id()` and subscription `user_id` meta during `build_payload()`, and include in `upsert_key()` to index by user/email; also send to Node from `send_event()`.【F:includes/class-dsb-events.php†L681-L766】【F:includes/class-dsb-db.php†L22-L64】【F:includes/class-dsb-db.php†L113-L144】
2. **Always set `customer_name`**: Capture `$order->get_billing_first_name()`/`get_billing_last_name()` (or WP user display name when no order) in payload and forward to Node/DB so rows are populated even when order is absent.【F:includes/class-dsb-events.php†L681-L766】
3. **Always set `subscription_status`**: Include status from WPS hooks or `$order->get_status()` mapping when building payload, and persist it through `send_event()`/`upsert_key()` schema so Node/local DB store it.【F:includes/class-dsb-events.php†L96-L220】【F:includes/class-dsb-db.php†L22-L64】【F:includes/class-dsb-client.php†L329-L395】
4. **Upsert using `(wp_user_id OR customer_email)`**: Extend schema with `wp_user_id` and a unique index on either `(wp_user_id)` or `(customer_email)` plus adjust `upsert_key()` lookup to search by those identifiers before inserting, so same customer updates existing row even if subscription_id differs.【F:includes/class-dsb-db.php†L22-L64】【F:includes/class-dsb-db.php†L113-L144】
5. **Prevent duplicate rows across hooks**: Change upsert matching to use user/email identity in addition to subscription_id, and update the duplicate-event guard to rely on DB state (e.g., last_action/valid_until) rather than only order meta `_dsb_last_sent_event`, so late hooks can update without creating new rows per subscription event.【F:includes/class-dsb-events.php†L7-L12】【F:includes/class-dsb-events.php†L438-L474】【F:includes/class-dsb-db.php†L113-L144】
